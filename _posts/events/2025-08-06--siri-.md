> id: https://sspai.com/post/101587

> link: https://sspai.com/post/101587

> title: Siri

# Siri
_Published on Wed, 06 Aug 2025 09:32:53 GMT_

![Article Cover Image](https://cdnfile.sspai.com/8/6/2025/article/8073c806-f2da-13a0-2756-0ae7cda90708.jpeg)  

其实在两年前，我就已经根据我派作者 @EstrellaXD 的文章《[HomeKit 智能升降桌是怎样炼成的](https://sspai.com/prime/story/homekit-smart-standing-desk)》，自己搓出来了适合我 HomeKit 升降桌的控制模块，并试产了几块。当时实现的功能很简单，就是通过模拟升降桌控制器模块的按键操作来实现将升降桌接入 HomeKit，进而可以使用 iPhone 和 Siri 来操作。

![](https://cdnfile.sspai.com/2025/08/05/523df79009281de2989ba2a349d420b5.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

当时做的小模块

这个方案一用就是三年。直到 25 年，我和伴侣搬进了 188 平的大豪斯，原本只需要承载我一个人需求的桌子，需要负担的事情也更多了。比如一起在我的世界养猫吃饭、码字、缝纫、做开发、化妆……总之，原本四个档位的高度设定对我来说是绰绰有余，但应对两个人的需求就不太够。

于是我又想起了升降桌智能化这事。我想，为什么不能有一个升降桌能让我多设定几个高度模式呢，或者可以让我们直接在手机或者键盘上输入数字，然后就自动升降到指定高度呢？

一开始，我想着能花点钱解决的事情，就别自己费尽心思去搞了。毕竟，前不久才刚做完一个大手术，自己没那个心力，同时自己尝试过开发硬件之后，便也知道了其中的重重困难。所以，我便在网上搜索「智能升降桌」，想着干脆买张新的好了。

事情当然不出意外地——出意外了。（要是没出意外你们现在也看不到这边文章了对吧。）在我搜索的过程中发现，如今很多升降桌的宣传虽然都加上了「智能」俩字，但某种程度上来讲，他们这个「智能」是基于传统「不可升降」桌子来定义的，而非智能家居时代里「能够接入家居平台」。

当然，我也很早就知道有品牌做出了支持米家的智能升降桌，但 3000 块左右的售价多少让我有点难堪——这么多钱，都够我俩去海南自驾旅行一周了。

![](https://cdnfile.sspai.com/2025/08/05/d4375b64b8e04ea51d11bd05b5a59912.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

行吧，既然没有厂家愿意做，愿意做的我买不起，那就还是只能自己上了。

折腾前的准备与忠告
---------

这里先给大家一个重要提醒：请在早上或中午开始探索，千万不要在傍晚开始。因为除了刷机和打《文明 6》，这个点开始探索，你很容易就见到凌晨四点五点六点或者刚刚天亮的城市了。

想要完成这个项目，你需要准备一些工具和环境：

-   **ESP32 开发板**，我选择的是 ESP32-C3；
-   **面包板**和若干**杜邦线**；
-   若干 **LED**，用来测试电平和查看状态等；
-   如果是方案二，还需要准备红外测距模块 **VL53L0x** 或 **VL53L1x**；
-   **电烙铁、焊锡、万用表**；
-   一套好用的**螺丝刀**，用来拆开升降桌控制模块；
-   一个 **USB 转 UART 模块**，可能需要用来刷固件或抓取 UART 数据；
-   一个**支持第三方加载项的 Home Assistant 环境**（用于安装 ESPHome）；以及
-   一个具有探索精神，且懂一些编程基础的你。

目标与核心思路
-------

在开始改造之前，得想明白自己要什么。前情里已经透露了核心的需求，但我又想着做都做了，不如做个完整功能的升降桌，把控制模块上所有的功能都给接入智能化控制好了。因此，现在的目标就比较明确：在不换升降桌控制器的前提下，实现——

-   输入高度数值后，升降桌调整到指定高度；
-   能设定超过四个高度模式；
-   将所有升降桌的物理按键都变成可用手机或语音控制的按钮；
-   接入 Home Assistant，进而可以桥接到 HomeKit，或者通过 Matter 接入各种平台。

有了目标，就可以思考改造的思路了。

过去，我根据 @EstrellaXD 所写[文章](https://sspai.com/prime/story/homekit-smart-standing-desk)而制作的控制模块里，只是单纯模拟了升降桌按下高度档位的物理按钮来实现 HomeKit 控制。但要实现上面的目标，最核心的问题就是如何获取升降桌当前的高度，否则后面的功能全都无从谈起。

拿到了关键的升降桌高度数据之后，还要让升降桌可以和 Home Assistant 交互：将升降桌数据传入 Home Assistant 实现展示，并通过 Home Assistant 发出控制指令来对升降桌高度进行操作。

这样看来，总体的实现逻辑并不难，只要攻破这两个核心难点，问题就被解决了。

方案一：基于 Upsy Desky 的协议破解
-----------------------

市面上许多升降桌都是通过一根网线来连接升降桌控制盒和控制面板的。如果我们能逆向拿到控制面板和控制盒之间的沟通数据，便可以直接在中间接入一个无线控制模块，来实现读取高度数据并接入智能家居平台。基于这个原理，我很快就在摸索的过程中发现了一个项目：[Upsy Desky](https://github.com/tjhorner/upsy-desky)。

看到这个项目的时候，我有种「哇原来人家早就在这里等着我了」的感觉，感叹现在互联网和开源社区真是越来越厉害了。我迫不及待地下载了 Upsy Desky 项目提供的源文件，打开了里面的电路图和 PCB，发现 Upsy Desky 的思路与我是完全一致了。

根据 Upsy Desky 提供的项目介绍文档和电路图，我了解到，许多升降桌的控制盒与控制面板都会通过 UART 协议来传输数据，只要在中间插入一个支持 UART 协议和能够接入 Home Assistant 的芯片，就能够实现所有的功能。

从电路图里可以看出，Upsy Desky 的核心就是一块 ESP32-WROOM-32 芯片。它是乐鑫科技推出的一款通用型 Wi-Fi 和蓝牙模块。

![](https://cdnfile.sspai.com/2025/08/05/fdd698b7dbde5eaa7aa564d205d78f91.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

明白了原理之后，我便开始尝试将这个方案应用到我的桌子上。我选择了更新的 ESP32-C3 芯片，因为它内置了 USB 接口，刷写固件更方便，可以节省一个 USB 转 UART 模块。

### ESPHome 介绍与安装

给 ESP32 编译固件用的是 ESPHome。ESPHome 是一个 Home Assistant 的官方加载项，可以让我们简单快速地为 ESP 系列芯片创建自定义固件。简单来说，步骤如下：

1.  在 Home Assistant 里，一键安装官方加载项商店里的 ESPHome；
2.  启动它，新建一个项目，选择对应的芯片；
3.  将作者提供的 Upsy Desky YAML 代码复制进去；
4.  修改适配 ESP32-C3 的部分；
5.  将 ESP32-C3 用 USB 连接到 Home Assistant 的运行主机上；
6.  保存，等待 ESPHome 自动编译固件和刷写。

要在 Home Assistant 里安装 ESPHome 也很简单，但前提是你运行的 Home Assistant 设置里有「加载项商店」这个选项（使用 Home Assistant OS 或 Supervised 安装方式即可，Docker 版较为复杂）。进入加载项商店里就能看到它，一键安装就行了。

![](https://cdnfile.sspai.com/2025/08/05/22c09db2ce04916006bb378174175e96.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

### Upsy Desky 固件导入及源代码解读

在 Upsy Desky 的 GitHub 里，作者已经提供了编译好的 bin 固件和源代码。如果和作者采用同款硬件，直接刷入他提供的固件即可。但由于我已经换了 ESP32-C3 作为主控芯片，就得自己编译一个适合 ESP32-C3 的固件。

将 Upsy Desky 的源代码从 GitHub 下载好之后，里面的 `firmware` 文件夹存放的就是固件源码。先将里面的 `addons` 文件夹整个复制到 Home Assistant 的 `config/esphom`e 文件夹里（可通过 Samba 或 File Editor 插件访问），然后再将里面的 `base.yaml` 也复制过来。

现在回到 Home Assistant 里刷新一下 ESPHome，就能看到被导入的 Upsy Desky 源码 YAML 文件了。现在，我们就可以来修改这里面的代码，让它适配 ESP32-C3。

第一步，修改芯片和框架类型：

```
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf
```

接着，是定义合适的 GPIO 引脚。**这一步至关重要，直接关系到后续能否成功。**由于 ESP32-WROOM-32 和 ESP32-C3 的 GPIO 引脚不一致，你需要根据你购买的开发板的引脚图（Pinout Diagram），重新定义要使用的 GPIO 引脚。只要避开图中标记为特殊用途的引脚，一般都可以使用。

![](https://cdnfile.sspai.com/2025/08/05/761f204993d744e02e37b3b29987c88e.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

请务必查找你所用开发板的引脚图

最后，添加 Wi-Fi 连接信息。建议使用 AP 热点模式，这样首次刷机后可以用手机连接设备创建的 Wi-Fi 来进行网络配置，避免密码输错导致无法联网。

```
wifi:
  # ... (省略 ssid 和 password)

# 开启通过 ap 热点设定 Wi-Fi
ap:
  ssid: "Upsy-Desky-Setup"
  password: "12345678"
```

当所有的代码修改完成后，将 ESP32-C3 开发板用 USB 线连接到 Home Assistant 主机，然后点击 ESPHome 右上角的 INSTALL，选择 _Plug into the computer running ESPHome..._，再找到你连接的 USB 设备，ESPHome 就会开始编译固件并自动刷写了。

![](https://cdnfile.sspai.com/2025/08/05/679f0cf07d19f4d37408f3f66e785888.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

### Upsy Desky 的局限性

一言以蔽之，Upsy Desky 方案并不支持我的升降桌类型。如果你的桌子恰好在[官方兼容列表](https://upsy-desky.tjhorner.dev/docs/reference/compatibility/)中，那么可以无痛使用。否则，就需要具备[逆向工程](https://upsy-desky.tjhorner.dev/docs/advanced/reverse-engineering/)的能力去分析和适配你桌子的 UART 数据，这对我来说难度过高。

![](https://cdnfile.sspai.com/2025/08/05/98829a4b50d7cfdcd0c186186b5391b6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

方案二：外部传感器（激光测距）
---------------

在方案一卡住后，一次偶然的下厨经历给了我灵感：既然无法从桌子「内部」读取高度，为何不从「外部」直接测量呢？

这便引出了我们的最终方案：在桌板底部安装一个激光测距传感器，测量桌板到地面的实时高度。这个高度数据通过 ESP 芯片发送给 Home Assistant。同时，ESP 芯片的 GPIO 引脚连接到升降桌的物理按键上，通过程序模拟按键点击，从而实现精确控制。

这个方案的额外好处是数据更准确。比如我给桌子加装了轮子后，桌子整体抬高了几厘米，传感器能测出真实高度，而桌子内置的高度显示则不会改变。

### 芯片及传感器选型

芯片我决定继续沿用 ESP32-C3。至于距离传感器，经过一番研究，我锁定了两款 ToF 红外距离传感器：VL53L0x 和它的「进阶款」 VL53L1x。其中——

-   **VL53L0x**：体积小，价格便宜，但典型测距范围只有 1.2 米。
-   **VL53L1x**：体积稍大，价格更高，但测距范围可达 2 米以上，精度和刷新率也更高。

![](https://cdnfile.sspai.com/2025/08/05/bd308b39f68c515b89c9bf1046803e80.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

我的升降桌加装轮子后最高可达 1.3 米，超出了 VL53L0x 的范围，因此 **VL53L1x 是本项目更稳妥的选择**。你可以根据自己升降桌的实际高度范围来决定。

![](https://cdnfile.sspai.com/2025/08/05/45f7877424abd49bc6214f47c4696c00.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

还是挺贵的...

成功获得高度数据
--------

拿到传感器后，需要将它与 ESP32-C3 连接起来。我们使用 I2C 协议通信，只需在 ESPHome 中定义 SDA 和 SCL 引脚即可：

```
i2c:
  sda: GPIO4
  scl: GPIO5
  scan: true
```

**注意：** VL53L0x 和 VL53L1x 的驱动方式有所不同。前者受 ESPHome 官方支持，后者需要引入第三方库。

如果你使用 **VL53L0x**，配置如下：

```
sensor:
  - platform: vl53l0x
    name: "升降桌高度"
    # ... 其他参数
    unit_of_measurement: "m"
```

如果你使用 **VL53L1x**，则需要先引入[第三方驱动](https://github.com/soldierkam/vl53l1x_sensor)，再进行配置：

```
external_components:
  - source: github://soldierkam/vl53l1x_sensor
    refresh: 1s

sensor:
  - platform: vl53l1x_sensor
    name: "升降桌高度"
    id: distance_sensor
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    update_interval: 500ms
    # 以下 roi 参数用于启用整个传感器阵列，让读数更稳定，直接复制即可
    distance_mode: MEDIUM
    timing_budget: 200ms
    roi_center: 
      x: 8
      y: 8
    roi_size: 
      x: 16
      y: 16
    filters:
      - multiply: 100 # 将单位从米转换为厘米
      - delta: 0.5    # 仅当高度变化超过0.5cm时才更新，防止读数抖动
```

其中，`roi_center` 和 `roi_size` 参数是告诉传感器启用全部感光元件进行测量，可以得到更准确、干扰更小的平均值。你可以把它想象成，`roi_center` 定义的是「你向哪里看」，而 `roi_size` 定义的是「眼睛睁多大」。

完成这些工作后，传感器终于成功地将桌面高度实时显示在了 Home Assistant 中。

![](https://cdnfile.sspai.com/2025/08/05/4ce23db68dd5c26542af46a69803817a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

早期的图已经截不到了，就给个最近的吧

如何进行升降桌控制？
----------

获取高度后，我们回归到最简单可靠的模拟点击方案。原理是：通过程序控制 ESP32-C3 的 GPIO 接口输出一个高电平信号，来模拟按下升降桌控制面板上的物理按键。**（注意：要使该方案生效，ESP32-C3 和升降桌控制电路必须共地。）**

![](https://cdnfile.sspai.com/2025/08/05/3b6aa79d55ae209fcc1ae9c38e69f62c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

原理图，请务必注意共地连接

### 搭建测试电路

我们可以先在面包板上搭建测试电路。根据 ESP32-C3 的引脚图连接硬件，并将传感器用胶带临时固定在桌底测试。

![](https://cdnfile.sspai.com/2025/08/05/c86ae74282263929bbcd6e2b488b4855.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

测试电路，供电直接采用 USB-C 接口

![](https://cdnfile.sspai.com/2025/08/05/e929bca125808411059a42e0ad6ec78d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

用胶带固定在桌底用于测试的 VL53L1x

### 撰写代码

有了高度数据和模拟按键的能力，我们就可以在 ESPHome 中编写完整的控制逻辑了。以下是核心代码片段，你可以根据自己的需求进行修改和扩展。

**第一部分：基础定义**

```
# ... (此处省略设备名称、Wi-Fi、API等基础配置) ...

# 开发板类型及框架，这里需要你查看自己的开发板类型，并根据商家或数据手册的描述来写
esp32:
  board: airm2m_core_esp32c3 # 示例板型，请替换
  framework:
    type: arduino

# 打开 ESP32-C3 的蓝牙网关功能 (可选)
bluetooth_proxy:
  active: true
```

**第二部分：接口定义**

```
# ... (此处省略 i2c 和 external_components 定义) ...

# 定义用于模拟按键的输出引脚
output:
  - platform: gpio
    id: output_up
    pin: GPIO2
  - platform: gpio
    id: output_down
    pin: GPIO3
  - platform: gpio
    id: output_preset1
    pin: GPIO6
  # ... 根据需要定义更多
```

**第三部分：核心逻辑 (开关、传感器与数字输入)**

```
# 定义互锁的上升/下降开关
switch:
  - platform: output
    id: switch_up
    name: "高度上升"
    output: output_up
    on_turn_on:
      - switch.turn_off: switch_down
  - platform: output
    id: switch_down
    name: "高度下降"
    output: output_down
    on_turn_on:
      - switch.turn_off: switch_up

# 定义传感器，并加入最高/最低安全限位
sensor:
  - platform: vl53l1x_sensor
    # ... (此处省略传感器具体参数) ...
    on_value:
      then:
        # 最高高度安全限制
        - if:
            condition:
              and:
                - switch.is_on: switch_up
                - lambda: 'return x >= 125.0;'
            then:
              - switch.turn_off: switch_up
        # 最低高度安全限制
        - if:
            condition:
              and:
                - switch.is_on: switch_down
                - lambda: 'return x <= 65.0;'
            then:
              - switch.turn_off: switch_down

# 手动设定任意高度的数字输入框
number:
  - platform: template
    name: "设定高度"
    id: target_height
    unit_of_measurement: "cm"  
    min_value: 65.0
    max_value: 125.0
    step: 0.5
    mode: box
    optimistic: true
    on_value:
      then:
        # 1. 安全第一：停止当前所有马达动作
        - switch.turn_off: switch_up
        - switch.turn_off: switch_down
        - delay: 200ms

        # 2. 判断是否需要上升
        - if:
            condition:
              lambda: 'return x > id(distance_sensor).state;' # 如果目标高度 > 当前高度
            then:
              - switch.turn_on: switch_up
              - wait_until:
                  condition:
                    lambda: 'return id(distance_sensor).state >= x;' # 等待，直到当前高度 >= 目标高度
              - switch.turn_off: switch_up

        # 3. 判断是否需要下降
        - if:
            condition:
              lambda: 'return x < id(distance_sensor).state;' # 如果目标高度 < 当前高度
            then:
              - switch.turn_on: switch_down
              - wait_until:
                  condition:
                    lambda: 'return id(distance_sensor).state <= x;' # 等待，直到当前高度 <= 目标高度
              - switch.turn_off: switch_down
```

至此，整个程序就近乎完整实现了我对智能升降桌的需求了。

到了这一步，也宣告着整个项目的探索阶段完工，电路和程序的可行性都已经得到验证，可以进行总装了。

接入智能家居平台，真正实现智能化
----------------

现在，这个升降桌智能控制模块在刷入 ESPHome 固件之后，就会自动在 Home Assistant 里被发现，一键接入后就能看到我们之前定义的那些传感器和开关实体。

![](https://cdnfile.sspai.com/2025/08/05/505e4846761b142cf7a5c92fa5f57533.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

### 接入 HomeKit

由于 HomeKit 没有「升降桌」这个设备类型，我们只能通过模拟「开关」或「插座」的方式来接入。得益于我们代码中丰富的逻辑，可以将「高度模式选择」这个 \`select\` 实体（完整代码可在原文找到）桥接到 HomeKit，它会显示为一个排插，每个插座对应一个高度模式。

![](https://cdnfile.sspai.com/2025/08/05/6c81914cf355a6278b0e5836c05a7d2c.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)![](https://cdnfile.sspai.com/2025/08/05/22ea677e0123e56da662ec2b10efb02a.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

这样，不仅可以在「家庭」App 中点击切换模式，还能直接用 Siri 进行语音控制。

### 再给它安排一个语音精灵吧

我将一个 Aqara 语音伴侣放在桌上，通过其 Matter 信号同步能力，可以创建自定义语音指令。例如，我说「坐下模式」，Aqara 会发送一个信号给 Home Assistant，触发一个自动化，将桌子调整到预设的坐下高度。

![](https://cdnfile.sspai.com/2025/08/05/c26af4156e83380bbe6b00faae91d4de.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)![](https://cdnfile.sspai.com/2025/08/05/d3a8ad6ec9b7cf121b7ec4b3e7ad1924.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

### 甚至还能用妙控键盘

借助 Keyboard Maestro，我将妙控键盘上闲置的 F13-F19 按键映射为控制升降桌的快捷键。按下按键时，执行一条 Shell 指令来调用 Home Assistant 的 API。

```
curl -X POST -H "Authorization: Bearer [你的Home Assistant token]" \
  -H "Content-Type: application/json" \
  -d '{"entity_id": "select.desk_mode_selector", "option": "站立模式"}' \
  http://[你的HA地址]:8123/api/services/select/select_option
```

注意，需要先在 Home Assistant 的个人主页中生成一个长期访问令牌 (Token)。

![](https://cdnfile.sspai.com/2025/08/05/7a5a1e911c08fa05d00a8104631ed588.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1/format/webp)

我知道打错字了......

### 当然，最重要的是自动化

有了智能化的升降桌，最终极的玩法是自动化。例如，搭配一个人体和压力传感器，实现「检测到久坐一小时后，自动将桌子升到站立高度」，强制自己站坐交替，保护腰椎。

ESPHome 的坑
----------

到这里，干货已基本讲完。但实际上，哪怕你完全照着做，也可能会遇到一些坑，主要集中在 ESPHome 的编译上。

最常见的问题是开发板不兼容。在购买 ESP32-C3 开发板时，**务必向商家确认其在 ESPHome 中应选择的** `**board**` **类型**。如果选错，固件即使刷入也无法正常启动，设备会一直显示 OFFLINE。

例如，我这块 「Powered by LuatOS」 的板子，就不能用默认的 `esp32-c3-devkitm-1`，而需要手动选择 `airm2m_core_esp32c3` 类型，并且将框架 framework 设置为 `arduino` 而非 `esp-idf`。

此外，还可能遇到 ESPHome 版本与芯片的兼容性问题，或者一些玄学的编译报错。总之，这个过程需要耐心和一定的解决问题的能力，但相信你如果决心探索，就一定能成功。

结语
--

相比前几次的自制硬件探索，这次的过程虽然更加曲折，但有了此前项目的探索经验，再加上 AI 工具的助力，我也还是成功地跑通了一套自己的方案。

只不过这个方案不那么有普适性，如果要适配更多的桌子，还需要进一步的开发，我虽然有着计划，但短期内靠自己肯定是做不来了。不过想来也有些有趣，自己很多年前做的选择，却冥冥之中让我有了更多折腾的创意 —— 如果以前没有贪便宜买了杂牌升降桌，那我很可能就只是给大家搬运一下 Upsy Desky 这个现成的开源项目，就没有后续的各种故事了。

也算是在好几年后重新再找回一些探索的快乐了。就是写完这篇文章的时候，已经是凌晨四点半，得赶紧休息了。就让我们难忘今宵，下次的折腾再见。
